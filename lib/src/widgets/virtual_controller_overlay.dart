/// Virtual Controller Overlay Widget
///
/// Renders virtual controls as an overlay.
/// Handles touch input and generates InputEvents.
library;

import 'package:flutter/material.dart';
import '../models/virtual_controller_models.dart';
import '../models/input_event.dart';
import 'controls/joystick_widget.dart';
import 'controls/dpad_widget.dart';
import 'controls/key_widget.dart';
import 'controls/button_widget.dart';
import 'controls/mouse_button_widget.dart';
import 'controls/mouse_wheel_widget.dart';
import 'controls/split_mouse_widget.dart';
import 'controls/scroll_stick_widget.dart';
import 'controls/custom_widget.dart';
import 'shared/default_control_widget.dart';
import '../utils/control_geometry.dart';

/// Overlay widget that renders all virtual controls.
class VirtualControllerOverlay extends StatefulWidget {
  /// Creates a virtual controller overlay.
  const VirtualControllerOverlay({
    super.key,
    required this.definition,
    required this.state,
    required this.onInputEvent,
    this.opacity = 0.5,
    this.showLabels = true,
  });

  final VirtualControllerLayout definition;

  final VirtualControllerState state;

  /// Callback for input events generated by controls.
  final void Function(InputEvent event) onInputEvent;

  /// Global opacity for the overlay.
  final double opacity;

  /// Whether to show labels on controls.
  final bool showLabels;

  @override
  State<VirtualControllerOverlay> createState() =>
      _VirtualControllerOverlayState();
}

class _VirtualControllerOverlayState extends State<VirtualControllerOverlay> {
  List<_ResolvedControl> _resolvedControls = [];
  Size _lastScreenSize = Size.zero;
  VirtualControllerLayout? _lastDefinition;
  VirtualControllerState? _lastState;

  @override
  void didUpdateWidget(VirtualControllerOverlay oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.definition != widget.definition ||
        oldWidget.state != widget.state) {
      _resolvedControls.clear();
      _lastScreenSize = Size.zero;
      _lastDefinition = null;
      _lastState = null;
    }
  }

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final screenSize = Size(constraints.maxWidth, constraints.maxHeight);

        if (screenSize != _lastScreenSize ||
            _resolvedControls.isEmpty ||
            _lastDefinition != widget.definition ||
            _lastState != widget.state) {
          _resolvedControls = _resolveControls(
            widget.definition.controls,
            widget.state,
          );
          _lastScreenSize = screenSize;
          _lastDefinition = widget.definition;
          _lastState = widget.state;
        }

        return Stack(
          children: [
            for (final item in _resolvedControls)
              _buildPositionedControl(item, screenSize),
          ],
        );
      },
    );
  }

  List<_ResolvedControl> _resolveControls(
    List<VirtualControl> controls,
    VirtualControllerState state,
  ) {
    final stateById = state.byId;
    final resolved = <_ResolvedControl>[];
    for (final control in controls) {
      final s = stateById[control.id];
      final layout = s?.layout ?? control.layout;
      final opacity = (s?.opacity ?? 1.0).clamp(0.0, 1.0);
      if (control is VirtualKeyCluster) {
        final keys = control.expandToKeys(layout);
        for (final k in keys) {
          resolved.add(_ResolvedControl(
            control: k,
            layout: k.layout,
            opacity: opacity,
          ));
        }
      } else {
        resolved.add(_ResolvedControl(
          control: control,
          layout: layout,
          opacity: opacity,
        ));
      }
    }
    return resolved;
  }

  Widget _buildPositionedControl(_ResolvedControl item, Size screenSize) {
    final rect =
        ControlGeometry.occupiedRect(item.control, item.layout, screenSize);

    return Positioned(
      left: rect.left,
      top: rect.top,
      width: rect.width,
      height: rect.height,
      child: Opacity(
        opacity: (widget.opacity * item.opacity).clamp(0.0, 1.0),
        child: _buildControlWidget(item.control),
      ),
    );
  }

  Widget _buildControlWidget(VirtualControl control) {
    return switch (control) {
      VirtualJoystick c => VirtualJoystickWidget(
          control: c,
          onInputEvent: widget.onInputEvent,
        ),
      VirtualDpad c => VirtualDpadWidget(
          control: c,
          onInputEvent: widget.onInputEvent,
        ),
      VirtualKey c => VirtualKeyWidget(
          control: c,
          onInputEvent: widget.onInputEvent,
          showLabel: widget.showLabels,
        ),
      VirtualMouseButton c => VirtualMouseButtonWidget(
          control: c,
          onInputEvent: widget.onInputEvent,
          showLabel: widget.showLabels,
        ),
      VirtualMouseWheel c => VirtualMouseWheelWidget(
          control: c,
          onInputEvent: widget.onInputEvent,
        ),
      VirtualSplitMouse c => VirtualSplitMouseWidget(
          control: c,
          onInputEvent: widget.onInputEvent,
        ),
      VirtualScrollStick c => VirtualScrollStickWidget(
          control: c,
          onInputEvent: widget.onInputEvent,
        ),
      VirtualButton c => VirtualButtonWidget(
          control: c,
          onInputEvent: widget.onInputEvent,
          showLabel: widget.showLabels,
        ),
      VirtualCustomControl c => VirtualCustomWidget(
          control: c,
          onInputEvent: widget.onInputEvent,
          showLabel: widget.showLabels,
        ),
      _ => DefaultControlWidget(control: control),
    };
  }
}

class _ResolvedControl {
  final VirtualControl control;
  final ControlLayout layout;
  final double opacity;

  const _ResolvedControl({
    required this.control,
    required this.layout,
    required this.opacity,
  });
}
