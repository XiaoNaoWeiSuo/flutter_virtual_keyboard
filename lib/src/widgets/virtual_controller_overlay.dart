/// Virtual Controller Overlay Widget
///
/// Renders virtual controls as an overlay.
/// Handles touch input and generates InputEvents.
library;

import 'package:flutter/material.dart';
import 'package:flutter/services.dart' show SystemUiMode;
import '../core/dynamic_control_factory.dart';
import '../models/virtual_controller_models.dart';
import '../models/input_event.dart';
import 'controls/joystick_widget.dart';
import 'controls/dpad_widget.dart';
import 'controls/key_widget.dart';
import 'controls/button_widget.dart';
import 'controls/mouse_button_widget.dart';
import 'controls/mouse_wheel_widget.dart';
import 'controls/split_mouse_widget.dart';
import 'controls/scroll_stick_widget.dart';
import 'controls/custom_widget.dart';
import 'controls/macro_button_widget.dart';
import 'shared/default_control_widget.dart';
import '../utils/control_geometry.dart';
import '../theme/virtual_control_theme.dart';
import 'system_ui_mode_scope.dart';

/// Overlay widget that renders all virtual controls.
class VirtualControllerOverlay extends StatefulWidget {
  /// Creates a virtual controller overlay.
  const VirtualControllerOverlay({
    super.key,
    required this.definition,
    required this.state,
    required this.onInputEvent,
    this.opacity = 0.5,
    this.showLabels = true,
    this.immersive = true,
    this.theme = const DefaultVirtualControlTheme(),
  });

  final VirtualControllerLayout definition;

  final VirtualControllerState state;

  /// Callback for input events generated by controls.
  final void Function(InputEvent event) onInputEvent;

  /// Global opacity for the overlay.
  final double opacity;

  /// Whether to show labels on controls.
  final bool showLabels;

  final bool immersive;

  final VirtualControlTheme theme;

  @override
  State<VirtualControllerOverlay> createState() =>
      _VirtualControllerOverlayState();
}

class _VirtualControllerOverlayState extends State<VirtualControllerOverlay> {
  List<_ResolvedControl> _resolvedControls = [];
  Size _lastScreenSize = Size.zero;
  VirtualControllerLayout? _lastDefinition;
  VirtualControllerState? _lastState;

  @override
  void didUpdateWidget(VirtualControllerOverlay oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.definition != widget.definition ||
        oldWidget.state != widget.state) {
      _resolvedControls.clear();
      _lastScreenSize = Size.zero;
      _lastDefinition = null;
      _lastState = null;
    }
  }

  @override
  Widget build(BuildContext context) {
    return SystemUiModeScope(
      mode: widget.immersive ? SystemUiMode.immersiveSticky : null,
      child: LayoutBuilder(
        builder: (context, constraints) {
          final screenSize = Size(constraints.maxWidth, constraints.maxHeight);

          if (screenSize != _lastScreenSize ||
              _resolvedControls.isEmpty ||
              _lastDefinition != widget.definition ||
              _lastState != widget.state) {
            _resolvedControls = _resolveControls(
              widget.definition.controls,
              widget.state,
            );
            _lastScreenSize = screenSize;
            _lastDefinition = widget.definition;
            _lastState = widget.state;
          }

          return Stack(
            children: [
              for (final item in _resolvedControls)
                _buildPositionedControl(item, screenSize),
            ],
          );
        },
      ),
    );
  }

  List<_ResolvedControl> _resolveControls(
    List<VirtualControl> controls,
    VirtualControllerState state,
  ) {
    final stateById = state.byId;
    final definitionIds = controls.map((c) => c.id).toSet();
    final resolved = <_ResolvedControl>[];
    for (final control in controls) {
      final s = stateById[control.id];
      final layout = s?.layout ?? control.layout;
      final opacity = (s?.opacity ?? 1.0).clamp(0.0, 1.0);
      final effectiveControl = widget.theme.decorate(_applyStateToControl(control, s));
      if (control is VirtualKeyCluster) {
        final keys = (effectiveControl as VirtualKeyCluster).expandToKeys(layout);
        for (final k in keys) {
          resolved.add(_ResolvedControl(
            control: widget.theme.decorate(k),
            layout: k.layout,
            opacity: opacity,
          ));
        }
      } else {
        resolved.add(_ResolvedControl(
          control: effectiveControl,
          layout: layout,
          opacity: opacity,
        ));
      }
    }

    for (final s in state.controls) {
      if (definitionIds.contains(s.id)) continue;
      final dynamic = dynamicControlFromId(s.id, s.layout, runtimeDefaults: true);
      if (dynamic == null) continue;
      final effectiveDynamic = widget.theme.decorate(_applyStateToControl(dynamic, s));
      resolved.add(_ResolvedControl(
        control: effectiveDynamic,
        layout: s.layout,
        opacity: (s.opacity).clamp(0.0, 1.0),
      ));
    }
    return resolved;
  }

  Widget _buildPositionedControl(_ResolvedControl item, Size screenSize) {
    final rect =
        ControlGeometry.occupiedRect(item.control, item.layout, screenSize);

    return Positioned(
      left: rect.left,
      top: rect.top,
      width: rect.width,
      height: rect.height,
      child: Opacity(
        opacity: (widget.opacity * item.opacity).clamp(0.0, 1.0),
        child: _buildControlWidget(item.control),
      ),
    );
  }

  Widget _buildControlWidget(VirtualControl control) {
    return switch (control) {
      VirtualJoystick c => VirtualJoystickWidget(
          control: c,
          onInputEvent: widget.onInputEvent,
        ),
      VirtualDpad c => VirtualDpadWidget(
          control: c,
          onInputEvent: widget.onInputEvent,
        ),
      VirtualKey c => VirtualKeyWidget(
          control: c,
          onInputEvent: widget.onInputEvent,
          showLabel: widget.showLabels,
        ),
      VirtualMouseButton c => VirtualMouseButtonWidget(
          control: c,
          onInputEvent: widget.onInputEvent,
          showLabel: widget.showLabels,
        ),
      VirtualMouseWheel c => VirtualMouseWheelWidget(
          control: c,
          onInputEvent: widget.onInputEvent,
        ),
      VirtualSplitMouse c => VirtualSplitMouseWidget(
          control: c,
          onInputEvent: widget.onInputEvent,
        ),
      VirtualScrollStick c => VirtualScrollStickWidget(
          control: c,
          onInputEvent: widget.onInputEvent,
        ),
      VirtualButton c => VirtualButtonWidget(
          control: c,
          onInputEvent: widget.onInputEvent,
          showLabel: widget.showLabels,
        ),
      VirtualCustomControl c => VirtualCustomWidget(
          control: c,
          onInputEvent: widget.onInputEvent,
          showLabel: widget.showLabels,
        ),
      VirtualMacroButton c => VirtualMacroButtonWidget(
          control: c,
          onInputEvent: widget.onInputEvent,
          showLabel: widget.showLabels,
        ),
      _ => DefaultControlWidget(control: control),
    };
  }
}

VirtualControl _applyStateToControl(
  VirtualControl control,
  VirtualControlState? state,
) {
  if (state == null || state.config.isEmpty) return control;
  final mergedConfig = Map<String, dynamic>.from(control.config);
  mergedConfig.addAll(state.config);

  if (control is VirtualJoystick) {
    return VirtualJoystick(
      id: control.id,
      label: control.label,
      layout: control.layout,
      trigger: control.trigger,
      config: mergedConfig,
      actions: control.actions,
      deadzone: control.deadzone,
      mode: control.mode,
      stickType: control.stickType,
      keys: control.keys,
      axes: control.axes,
      style: control.style,
      feedback: control.feedback,
    );
  }

  if (control is VirtualDpad) {
    final enable3D = mergedConfig['enable3D'] is bool
        ? mergedConfig['enable3D'] as bool
        : control.enable3D;
    return VirtualDpad(
      id: control.id,
      label: control.label,
      layout: control.layout,
      trigger: control.trigger,
      config: mergedConfig,
      actions: control.actions,
      directions: control.directions,
      enable3D: enable3D,
      style: control.style,
      feedback: control.feedback,
    );
  }

  if (control is VirtualButton) {
    return VirtualButton(
      id: control.id,
      label: control.label,
      layout: control.layout,
      trigger: control.trigger,
      binding: control.binding,
      config: mergedConfig,
      actions: control.actions,
      style: control.style,
      feedback: control.feedback,
    );
  }

  if (control is VirtualKey) {
    return VirtualKey(
      id: control.id,
      label: control.label,
      layout: control.layout,
      trigger: control.trigger,
      config: mergedConfig,
      binding: control.binding,
      style: control.style,
      feedback: control.feedback,
    );
  }

  if (control is VirtualMouseButton) {
    return VirtualMouseButton(
      id: control.id,
      label: control.label,
      layout: control.layout,
      trigger: control.trigger,
      config: mergedConfig,
      button: control.button,
      clickType: control.clickType,
      style: control.style,
      feedback: control.feedback,
    );
  }

  if (control is VirtualMouseWheel) {
    return VirtualMouseWheel(
      id: control.id,
      label: control.label,
      layout: control.layout,
      trigger: control.trigger,
      config: mergedConfig,
      direction: control.direction,
      step: control.step,
      style: control.style,
      feedback: control.feedback,
    );
  }

  if (control is VirtualKeyCluster) {
    return VirtualKeyCluster(
      id: control.id,
      label: control.label,
      layout: control.layout,
      trigger: control.trigger,
      config: mergedConfig,
      grid: control.grid,
      keySize: control.keySize,
      spacing: control.spacing,
      style: control.style,
      feedback: control.feedback,
    );
  }

  if (control is VirtualMacroButton) {
    final configSeq = mergedConfig['sequence'] as List?;
    final sequence = configSeq == null
        ? control.sequence
        : configSeq.map((e) {
            if (e is MacroSequenceItem) return e;
            return MacroSequenceItem.fromJson(Map<String, dynamic>.from(e));
          }).toList();
    final configLabel = mergedConfig['label'];
    final appliedLabel = (configLabel is String && configLabel.trim().isNotEmpty)
        ? configLabel.trim()
        : control.label;
    return VirtualMacroButton(
      id: control.id,
      label: appliedLabel,
      layout: control.layout,
      trigger: control.trigger,
      config: mergedConfig,
      sequence: sequence,
      style: control.style,
      feedback: control.feedback,
    );
  }

  if (control is VirtualScrollStick) {
    return VirtualScrollStick(
      id: control.id,
      label: control.label,
      layout: control.layout,
      trigger: control.trigger,
      config: mergedConfig,
      sensitivity: control.sensitivity,
      style: control.style,
      feedback: control.feedback,
    );
  }

  if (control is VirtualSplitMouse) {
    return VirtualSplitMouse(
      id: control.id,
      label: control.label,
      layout: control.layout,
      trigger: control.trigger,
      config: mergedConfig,
      style: control.style,
      feedback: control.feedback,
    );
  }

  if (control is VirtualCustomControl) {
    return VirtualCustomControl(
      id: control.id,
      label: control.label,
      layout: control.layout,
      trigger: control.trigger,
      config: mergedConfig,
      actions: control.actions,
      customData: control.customData,
      style: control.style,
      feedback: control.feedback,
    );
  }

  return control;
}

class _ResolvedControl {
  final VirtualControl control;
  final ControlLayout layout;
  final double opacity;

  const _ResolvedControl({
    required this.control,
    required this.layout,
    required this.opacity,
  });
}
