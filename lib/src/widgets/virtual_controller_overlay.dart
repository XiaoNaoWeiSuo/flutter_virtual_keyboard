/// Virtual Controller Overlay Widget
///
/// Renders virtual controls as an overlay.
/// Handles touch input and generates InputEvents.
library;

import 'package:flutter/material.dart';
import '../models/virtual_controller_models.dart';
import '../models/input_event.dart';
import 'controls/joystick_widget.dart';
import 'controls/dpad_widget.dart';
import 'controls/key_widget.dart';
import 'controls/button_widget.dart';
import 'controls/mouse_button_widget.dart';
import 'controls/mouse_wheel_widget.dart';
import 'controls/split_mouse_widget.dart';
import 'controls/scroll_stick_widget.dart';
import 'controls/custom_widget.dart';
import 'shared/default_control_widget.dart';
import '../utils/control_geometry.dart';

/// Overlay widget that renders all virtual controls.
class VirtualControllerOverlay extends StatefulWidget {
  /// Creates a virtual controller overlay.
  const VirtualControllerOverlay({
    super.key,
    required this.definition,
    required this.state,
    required this.onInputEvent,
    this.opacity = 0.5,
    this.showLabels = true,
  });

  final VirtualControllerLayout definition;

  final VirtualControllerState state;

  /// Callback for input events generated by controls.
  final void Function(InputEvent event) onInputEvent;

  /// Global opacity for the overlay.
  final double opacity;

  /// Whether to show labels on controls.
  final bool showLabels;

  @override
  State<VirtualControllerOverlay> createState() =>
      _VirtualControllerOverlayState();
}

class _VirtualControllerOverlayState extends State<VirtualControllerOverlay> {
  List<_ResolvedControl> _resolvedControls = [];
  Size _lastScreenSize = Size.zero;
  VirtualControllerLayout? _lastDefinition;
  VirtualControllerState? _lastState;

  @override
  void didUpdateWidget(VirtualControllerOverlay oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.definition != widget.definition ||
        oldWidget.state != widget.state) {
      _resolvedControls.clear();
      _lastScreenSize = Size.zero;
      _lastDefinition = null;
      _lastState = null;
    }
  }

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final screenSize = Size(constraints.maxWidth, constraints.maxHeight);

        if (screenSize != _lastScreenSize ||
            _resolvedControls.isEmpty ||
            _lastDefinition != widget.definition ||
            _lastState != widget.state) {
          _resolvedControls = _resolveControls(
            widget.definition.controls,
            widget.state,
          );
          _lastScreenSize = screenSize;
          _lastDefinition = widget.definition;
          _lastState = widget.state;
        }

        return Stack(
          children: [
            for (final item in _resolvedControls)
              _buildPositionedControl(item, screenSize),
          ],
        );
      },
    );
  }

  List<_ResolvedControl> _resolveControls(
    List<VirtualControl> controls,
    VirtualControllerState state,
  ) {
    final stateById = state.byId;
    final definitionIds = controls.map((c) => c.id).toSet();
    final resolved = <_ResolvedControl>[];
    for (final control in controls) {
      final s = stateById[control.id];
      final layout = s?.layout ?? control.layout;
      final opacity = (s?.opacity ?? 1.0).clamp(0.0, 1.0);
      if (control is VirtualKeyCluster) {
        final keys = control.expandToKeys(layout);
        for (final k in keys) {
          resolved.add(_ResolvedControl(
            control: k,
            layout: k.layout,
            opacity: opacity,
          ));
        }
      } else {
        resolved.add(_ResolvedControl(
          control: control,
          layout: layout,
          opacity: opacity,
        ));
      }
    }

    for (final s in state.controls) {
      if (definitionIds.contains(s.id)) continue;
      final dynamic = _dynamicControlFromId(s.id, s.layout);
      if (dynamic == null) continue;
      resolved.add(_ResolvedControl(
        control: dynamic,
        layout: s.layout,
        opacity: (s.opacity).clamp(0.0, 1.0),
      ));
    }
    return resolved;
  }

  Widget _buildPositionedControl(_ResolvedControl item, Size screenSize) {
    final rect =
        ControlGeometry.occupiedRect(item.control, item.layout, screenSize);

    return Positioned(
      left: rect.left,
      top: rect.top,
      width: rect.width,
      height: rect.height,
      child: Opacity(
        opacity: (widget.opacity * item.opacity).clamp(0.0, 1.0),
        child: _buildControlWidget(item.control),
      ),
    );
  }

  Widget _buildControlWidget(VirtualControl control) {
    return switch (control) {
      VirtualJoystick c => VirtualJoystickWidget(
          control: c,
          onInputEvent: widget.onInputEvent,
        ),
      VirtualDpad c => VirtualDpadWidget(
          control: c,
          onInputEvent: widget.onInputEvent,
        ),
      VirtualKey c => VirtualKeyWidget(
          control: c,
          onInputEvent: widget.onInputEvent,
          showLabel: widget.showLabels,
        ),
      VirtualMouseButton c => VirtualMouseButtonWidget(
          control: c,
          onInputEvent: widget.onInputEvent,
          showLabel: widget.showLabels,
        ),
      VirtualMouseWheel c => VirtualMouseWheelWidget(
          control: c,
          onInputEvent: widget.onInputEvent,
        ),
      VirtualSplitMouse c => VirtualSplitMouseWidget(
          control: c,
          onInputEvent: widget.onInputEvent,
        ),
      VirtualScrollStick c => VirtualScrollStickWidget(
          control: c,
          onInputEvent: widget.onInputEvent,
        ),
      VirtualButton c => VirtualButtonWidget(
          control: c,
          onInputEvent: widget.onInputEvent,
          showLabel: widget.showLabels,
        ),
      VirtualCustomControl c => VirtualCustomWidget(
          control: c,
          onInputEvent: widget.onInputEvent,
          showLabel: widget.showLabels,
        ),
      _ => DefaultControlWidget(control: control),
    };
  }
}

class _ResolvedControl {
  final VirtualControl control;
  final ControlLayout layout;
  final double opacity;

  const _ResolvedControl({
    required this.control,
    required this.layout,
    required this.opacity,
  });
}

VirtualControl? _dynamicControlFromId(String id, ControlLayout layout) {
  if (id.startsWith('btn_')) {
    final parts = id.split('_');
    if (parts.length >= 2) {
      final code = parts[1];
      final btn = InputBindingRegistry.tryGetGamepadButton(code) ??
          InputBindingRegistry.registerGamepadButton(code: code);
      return VirtualButton(
        id: id,
        label: btn.label ?? btn.code,
        layout: layout,
        trigger: TriggerType.hold,
        binding: GamepadButtonBinding(btn),
      );
    }
  }
  if (id.startsWith('mouse_')) {
    final parts = id.split('_');
    if (parts.length >= 2) {
      final button = parts[1];
      return VirtualMouseButton(
        id: id,
        label: button == 'middle' ? 'M' : button,
        layout: layout,
        trigger: button == 'right' ? TriggerType.hold : TriggerType.tap,
        button: button,
        config: const {},
      );
    }
  }
  if (id.startsWith('wheel_')) {
    final parts = id.split('_');
    if (parts.length >= 2) {
      final direction = parts[1];
      return VirtualMouseWheel(
        id: id,
        label: direction == 'up' ? '滑轮上' : '滑轮下',
        layout: layout,
        trigger: TriggerType.tap,
        direction: direction,
        config: const {'inputType': 'mouse_wheel'},
      );
    }
  }
  if (id.startsWith('split_mouse_')) {
    return VirtualSplitMouse(
      id: id,
      label: '',
      layout: layout,
      trigger: TriggerType.hold,
      config: const {},
    );
  }
  if (id.startsWith('scroll_stick_')) {
    return VirtualScrollStick(
      id: id,
      label: '',
      layout: layout,
      trigger: TriggerType.hold,
      config: const {},
    );
  }
  if (id.startsWith('dpad_')) {
    return VirtualDpad(
      id: id,
      label: '',
      layout: layout,
      trigger: TriggerType.hold,
      enable3D: true,
      directions: const {
        DpadDirection.up: GamepadButtonBinding(GamepadButtonId.dpadUp),
        DpadDirection.down: GamepadButtonBinding(GamepadButtonId.dpadDown),
        DpadDirection.left: GamepadButtonBinding(GamepadButtonId.dpadLeft),
        DpadDirection.right: GamepadButtonBinding(GamepadButtonId.dpadRight),
      },
      config: const {},
    );
  }
  if (id.startsWith('joystick_wasd_')) {
    return VirtualJoystick(
      id: id,
      label: '',
      layout: layout,
      trigger: TriggerType.hold,
      keys: const [
        KeyboardKey('W'),
        KeyboardKey('A'),
        KeyboardKey('S'),
        KeyboardKey('D'),
      ],
      config: const {
        'overlayLabels': ['W', 'A', 'S', 'D'],
        'overlayStyle': 'quadrant',
      },
    );
  }
  if (id.startsWith('joystick_arrows_')) {
    return VirtualJoystick(
      id: id,
      label: '',
      layout: layout,
      trigger: TriggerType.hold,
      keys: const [
        KeyboardKey('ArrowUp'),
        KeyboardKey('ArrowLeft'),
        KeyboardKey('ArrowDown'),
        KeyboardKey('ArrowRight'),
      ],
      config: const {
        'overlayLabels': ['↑', '←', '↓', '→'],
        'overlayStyle': 'quadrant',
      },
    );
  }
  if (id.startsWith('joystick_gamepad_left_')) {
    return VirtualJoystick(
      id: id,
      label: 'LS',
      layout: layout,
      trigger: TriggerType.hold,
      mode: 'gamepad',
      stickType: 'left',
      config: const {
        'centerLabel': 'L',
        'overlayStyle': 'center',
      },
    );
  }
  if (id.startsWith('joystick_gamepad_right_')) {
    return VirtualJoystick(
      id: id,
      label: 'RS',
      layout: layout,
      trigger: TriggerType.hold,
      mode: 'gamepad',
      stickType: 'right',
      config: const {
        'centerLabel': 'R',
        'overlayStyle': 'center',
      },
    );
  }
  if (id.startsWith('key_')) {
    final parts = id.split('_');
    if (parts.length >= 4) {
      final keyCode = Uri.decodeComponent(parts[1]);
      final modsRaw = parts[2];
      final modifiers = modsRaw == 'none'
          ? const <KeyboardKey>[]
          : Uri.decodeComponent(modsRaw)
              .split('+')
              .where((e) => e.trim().isNotEmpty)
              .map((e) => KeyboardKey(e).normalized())
              .toList(growable: false);
      final key = KeyboardKey(keyCode).normalized();
      return VirtualKey(
        id: id,
        label: key.code,
        layout: layout,
        trigger: TriggerType.tap,
        binding: KeyboardBinding(key: key, modifiers: modifiers),
        config: const {},
      );
    }
  }
  return null;
}
